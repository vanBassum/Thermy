import os
import sys
import subprocess

# --- Auto-install missing dependencies ---
def install_missing(package_name, import_name=None):
    import importlib
    try:
        importlib.import_module(import_name or package_name)
    except ImportError:
        print(f"[Setup] Installing missing dependency: {package_name} ...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", package_name])
        print(f"[Setup] Successfully installed {package_name}")
    finally:
        globals()[import_name or package_name] = importlib.import_module(import_name or package_name)

install_missing("pyyaml", "yaml")
# --- End of auto-install section ---

SETTINGS_FILE = "fix_includes.yaml"

# Global list to track changes
changes = []


def log_change(action: str, path: str):
    changes.append((action, path))
    print(f"[{action}] {path}")


class ParseInfo:
    def __init__(self, path="", do_cmake=True, do_includes=False):
        self.path = path
        self.do_cmake = do_cmake
        self.do_includes = do_includes


class Settings:
    def __init__(self, parse_infos=None):
        self.parse_infos = parse_infos or [ParseInfo()]


def load_settings(settings_file: str) -> Settings:
    if not os.path.exists(settings_file):
        # Create default settings file
        settings = Settings()
        with open(settings_file, "w") as f:
            yaml.dump(settings.__dict__, f, sort_keys=False)
        log_change("Created default settings file", settings_file)
        return settings
    else:
        with open(settings_file, "r") as f:
            data = yaml.safe_load(f)
        parse_infos = [
            ParseInfo(
                path=item.get("path", ""),
                do_cmake=item.get("doCMAKE", True),
                do_includes=item.get("doIncludes", False)
            )
            for item in data.get("parseInfos", [])
        ]
        print("Loaded Settings:")
        print(yaml.dump(data, sort_keys=False))
        return Settings(parse_infos)


def create_include_file(path: str, indent: int = 0):
    folder_name = os.path.basename(path)
    include_file = os.path.join(path, f"{folder_name}.h")

    with open(include_file, "w") as out:
        out.write("#pragma once\n\n")

        prefix = f"{' ' * (indent * 2)}{folder_name}"
        print(f"{prefix}{' ' * max(1, 20 - len(prefix))}( ", end="")

        for file in os.listdir(path):
            if file.endswith(".h") and file != f"{folder_name}.h":
                out.write(f'#include "{file}"\n')
                print(f"{file} ", end="")

        out.write("\n")
        print(")")

        for subdir in [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]:
            out.write(f'#include "{subdir}/{subdir}.h"\n')
            create_include_file(os.path.join(path, subdir), indent + 1)

    log_change("Updated include file", include_file)


def create_set_block_sources(path: str) -> str:
    files = []
    for root, _, filenames in os.walk(path):
        for f in filenames:
            if f.endswith((".c", ".cpp")):
                rel_path = os.path.relpath(os.path.join(root, f), path).replace("\\", "/")
                files.append(f'    "{rel_path}"')
    return "set(SOURCE_FILES_LIST\n" + "\n".join(files) + "\n)"


def create_set_block_includes(path: str) -> str:
    dirs = []
    for root, subdirs, _ in os.walk(path):
        for d in subdirs:
            rel = os.path.relpath(os.path.join(root, d), path).replace("\\", "/")
            dirs.append(f'    "{rel}"')
    return "set(INCLUDE_DIRS_LIST\n    .\n" + "\n".join(dirs) + "\n)"


def build_default_cmake_file(path: str) -> str:
    return f"""# This file is automatically generated by FixIncludes tool.

{create_set_block_sources(path)}

{create_set_block_includes(path)}

# Register component with ESP-IDF
idf_component_register()

# Apply source files and include directories
target_sources(${{COMPONENT_LIB}} PRIVATE ${{SOURCE_FILES_LIST}})
target_include_directories(${{COMPONENT_LIB}} PRIVATE ${{INCLUDE_DIRS_LIST}})
"""


def replace_set_block(content: str, block_name: str, replacement: str) -> str:
    start = content.find(f"set({block_name}")
    if start == -1:
        return content
    end = content.find(")", start)
    if end == -1:
        return content
    end = content.find("\n", end)
    if end == -1:
        end = len(content)
    return content[:start] + replacement + content[end:]


def fix_cmake_file(path: str):
    file_path = os.path.join(path, "CMakeLists.txt")
    original = ""
    if os.path.exists(file_path):
        with open(file_path, "r") as f:
            original = f.read()

    has_source = "set(SOURCE_FILES_LIST" in original
    has_include = "set(INCLUDE_DIRS_LIST" in original
    has_register = "idf_component_register(" in original

    if not (has_source and has_include and has_register):
        with open(file_path, "w") as f:
            f.write(build_default_cmake_file(path))
        log_change("Created new CMakeLists", file_path)
        return

    updated = replace_set_block(original, "SOURCE_FILES_LIST", create_set_block_sources(path))
    updated = replace_set_block(updated, "INCLUDE_DIRS_LIST", create_set_block_includes(path))

    if updated != original:
        with open(file_path, "w") as f:
            f.write(updated)
        log_change("Updated CMakeLists", file_path)
    else:
        log_change("No changes needed", file_path)


def process_settings(settings: Settings):
    for item in settings.parse_infos:
        full_path = os.path.abspath(item.path)

        if item.do_includes:
            create_include_file(full_path)

        if item.do_cmake:
            fix_cmake_file(full_path)

        print()


def main():
    settings = load_settings(SETTINGS_FILE)
    print("\nProcessing library header files and CMakeLists...\n")
    process_settings(settings)

    print("\n==== Summary of Changes ====")
    if changes:
        for action, path in changes:
            print(f"{action:25} {path}")
    else:
        print("No changes were made.")


if __name__ == "__main__":
    main()
